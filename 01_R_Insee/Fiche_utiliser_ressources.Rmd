# Bien utiliser les ressources informatiques avec `R`

::: {.recommandation data-latex=""}
* Il est essentiel de suivre régulièrement

utiliser la fonction `gc()`
Suivre la consommation de mémoire vive et l'utilisation des CPU.

:::







## Pourquoi est-il important de superviser sa session `R`?

Contrairement à SAS, `R` est un langage conçu pour traiter des données chargées dans la mémoire vive (RAM) de l'ordinateur. Cette caractéristique permet à `R` d'être relativement rapide, mais induit des difficultés lorsque les données sont volumineuses. **Le principal risque d'une mauvaise gestion de la mémoire est d'aboutir à une saturation de la mémoire vive**: la session `R` occupe l'intégralité de la mémoire vive ce qui ralentit les traitements voire paralyse l'ordinateur. Les problèmes de saturation de la RAM se traduisent généralement par un message du type `cannot allocate a vector of size ** Mb` (quand la session ne plante pas...). 

**Le risque de saturation de la mémoire vive est particulièrement fréquent lorsqu'on travaille avec une infrastructure informatique où la mémoire vive est partagée avec d'autres utilisateurs, comme c'est le cas dans l'environnement AUS.** Si plusieurs utilisateurs occupent chacun une grande quantité de mémoire vive sur la même machine virtuelle d'AUS, il est facile d'arriver à une situation de saturation qui paralyse tous les agents connectés sur cette machine virtuelle (voire fait planter leur session `R`).

**Le risque de saturation de la mémoire vive est aggravé par la façon dont `R` gère la mémoire.** En effet, une session `R` augmente automatiquement la quantité de mémoire vive qu'elle occupe lorsque les traitements réclament davantage de mémoire, mais elle ne la libère pas toujours lorsque les besoins en mémoire diminuent. Il est donc possible qu'une session `R` occupe beaucoup plus de mémoire que ce dont elle a besoin. Par exemple, si vous lancez une session `R`, que vous importez une table de données de 10 Go, puis que vous la supprimez immédiatement de votre session avec la fonction `rm()`, il est possible que votre session `R` continue à occuper inutilement 10 Go de mémoire vive, et ce quand bien même votre environnement `Rstudio` vous indique qu'il n'y a aucun objet en mémoire.

La conclusion est simple: suivre attentivement l'usage que votre session `R` fait de la mémoire vive est essentiel pour votre efficacité comme pour celles des autres agents.

## Comment limiter la consommation de mémoire vive avec `R`?



### Limiter la taille des objets en mémoire




- **Il est conseillé de sélectionner uniquement les colonnes dont vous avez besoin lorsque vous importer des données.** Toutes les fonctions d'importation de données présentées dans cette documentation comprennent une option permettant de choisir les colonnes. Le tableau qui suit vous indique le nom de l'option en fonction du format des données. Vous pouvez vous reporter à la fiche correspondante pour les détails sur son utilisation.

    | Format des données  | Fonction | _package_ | Option    |
    |---------------------|-----------|----------|----------------------|
    | Fichier plat (`.csv`, `.tsv`, `.txt`)   | `fread()`   | `data.table`    | `select`   |
    | Table SAS        | `read_sas()`     | `haven`    | `col_select`   |
    | Fichier `.xlsx`  | `read.xlsx()`    | `openxlsx`    | `cols`   |
    | Fichier `.xls`   | `read_excel()`   | `readxl`      | `range`   |
    | Fichier `.ods`   | `read_ods()`     | `readODS`     | `range`   |
    
- Dans le cas où vous ne savez pas quelles sont les colonnes dont vous avez besoin (parce que vous découvrez les données par exemple), **il est conseillé de commencer par importer un petit nombre de lignes** (10 000 par exemple) afin d'étudier les données et de choisir ensuite les colonnes à importer. Toutes les fonctions d'importation de données présentées dans cette documentation comprennent une option permettant de définir le nombre de lignes à importer. Le tableau qui suit vous indique le nom de l'option en fonction du format des données. Vous pouvez vous reporter à la fiche correspondante pour les détails sur son utilisation.

    | Format des données  | Fonction | _package_ | Option    |
    |---------------------|-----------|----------|----------------------|
    | Fichier plat (`.csv`, `.tsv`, `.txt`)   | `fread()`   | `data.table`    | `nrows`   |
    | Fichier plat (`.csv`, `.tsv`, `.txt`)   | `read_csv()`   | `readr`    | `n_max`   |
    | Table SAS   | `read_sas()`   | `haven`    | `n_max`   |
    | Fichier `.xlsx`   | `read.xlsx()`   | `openxlsx`    | `rows`   |
    | Fichier `.xls`   | `read_excel()`   | `readxl`      | `n_max`   |
    | Fichier `.ods`   | `read_ods()`   | `readODS`      | `range`   |




### Limiter le nombre d'objets en mémoire





### Nettoyer régulièrement la mémoire vive

Comme mentionné précédemment, une session `R` augmente automatiquement la quantité de mémoire vive qu'elle occupe lorsque les traitements réclament davantage de mémoire, mais ne la libère pas toujours lorsque les besoins en mémoire diminuent. Il est donc important de vérifier régulièrement que vous n'occupez pas plus de mémoire vive que nécessaire.

Pour ce faire, **la solution la plus simple consiste à utiliser la fonction `gc()`** (_garbage collection_, qui signifie littéralement "enlèvement des ordures"). Cette fonction analyse la mémoire vive occupée par la session `R`, et libère la mémoire qui est occupée inutilement. Il est vivement recommandé d'exécuter la fonction `gc()` après un traitement portant sur des données volumineuses. Voici une liste indicative d'opérations après lesquelles vous pouvez exécuter `gc()`:

- une jointure entre deux tables volumineuses;
- la suppression d'objets volumineux avec la fonction `rm()`;
- une estimation économétrique complexe.

::: {.remarque data-latex=""}
Plus la session `R` occupe de mémoire vive, plus la fonction `gc()` met de temps à nettoyer la mémoire. Ce nettoyage peut prendre jusqu'à plusieurs minutes si vous manipulez des données volumineuses.
:::



## Comment suivre la consommation de mémoire vive avec `R`?



Dans certains langages, il est nécessaire d'explicitement supprimer des objets pour que leur espace mémoire soit libéré. `R` adopte une approche différente, celle du **garbage collection** (GC). GC libère automatiquement la mémoire occupée par un objet qui n'existe plus (en inspectant les espaces qui pointent vers des noms d'objets n'existant pas). Même si `R` effectue fréquemment des GC, **il est nécessaire d'appeler la commande `gc()` de temps en temps (en particulier après l'appel d'une fonction ayant effectué un gros traitement) pour rendre de la RAM au système d'exploitation.** Sur un serveur partagé, cela permet de réduire les risques de saturation à cause de sessions inactives qui n'ont plus besoin de la mémoire qu'elles mobilisent^[@wickham2014advanced dans son ouvrage développe l'idée que la commande `gc()` est inutile car la GC étant automatique, évoquer `gc()` ne libère aucun espace mémoire mais prend du temps. En pratique, je trouve que c'est faux (`gc()` permet souvent de libérer plusieurs gigaoctets) et que sur un serveur partagé, c'est une règle de bonne conduite pour permettre à chacun d'avoir des chances de disposer de mémoire quand il en a besoin.]. 

Outre la lenteur d'exécution, **le principal risque d'une mauvaise gestion de la mémoire est d'aboutir à une saturation de la RAM**. Les problèmes de saturation de la RAM se traduisent généralement par un message du type `cannot allocate a vector of size ** Mb` (quand la session ne *crashe* pas...). 








(les postes nomades de l'Insee ont 8 Go de RAM; les ressources d'un serveur sont partagées entre tous les utilisateurs)

Une session `R` augmente automatiquement la quantité de mémoire vive qu'elle occupe lorsque les traitements réclament davantage de mémoire, mais elle ne la libère pas toujours lorsque les besoins en mémoire diminuent. Il est donc possible qu'une session `R` occupe beaucoup plus de mémoire que ce dont elle a besoin. Par exemple, si vous lancez une session `R`, que vous importez une table de données de 10 Go, puis que vous la supprimez immédiatement de votre session avec la fonction `rm()`, il est possible que votre session `R` continue à occuper inutilement 10 Go de mémoire vive, et ce quand bien même votre environnement `Rstudio` vous indique qu'il n'y a aucun objet en mémoire.


**La solution la plus simple pour éviter d'occuper plus de mémoire vive que nécessaire consiste à utiliser la fonction `gc()`** (_garbage collection_, qui signifie littéralement "enlèvement des ordures"). Cette fonction analyse la mémoire vive occupée par la session `R`, et libère la mémoire vive qui est occupée inutilement.




## Utiliser `R` et `Rstudio` à l'Insee?

- Présentation du Gitlab interne
- Configurer son accès à Gitlab (SSH, Putty etc.)
- Comment travailler à plusieurs avec Gitlab? Reprendre la partie 4.4 de la formation Travail Collaboratif sous R.

## Se former à `R` à l'Insee